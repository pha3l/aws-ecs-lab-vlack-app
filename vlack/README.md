# vlack

> Vue Slack Clone

## 1. Development Environment
To follow this tutorial, you will need the following tools:

- NodeJS and npm: [Download](https://nodejs.org/en/)
- Vue Cli: [Github](https://github.com/vuejs/vue-cli)
- Vue devtools extension for Chrome or Firefox (not necessary, but recommended) [Firefox](https://addons.mozilla.org/en-US/firefox/addon/vue-js-devtools/) / [Chrome](https://chrome.google.com/webstore/detail/vuejs-devtools/nhdogjmejiglipccpnnnanhbledajbpd?hl=en)
- A text editor with with Vue syntax support. (Technically not necessary, but highly recommended - VSCode is my editor of choice with the Vetur extension installed).

## 2. Setting Up The SPA
This application will be developed a single page application (SPA) using webpack as our build tools. Webpack can be difficulty to set up from scratch, but luckily the vue-cli provides a way to generate a webpack project that is preconfigured with VueJS.

The following command will generate a new VueJS webpack project:
``` bash
$ vue init webpack <project-name>
```

The cli will ask a few questions about the project:
- Project name: will default to the one you provided, so just hit enter
- Description: Give any description you want and hit enter
- Author: Your name goes here
- Vue build: Select `Runtime + Compiler`
- Install vue-router?: Type `Y`
- Use ESLint to lint your code?: Select `n` for this demo, but linting is reccommended for production applications.
- Set up unit tests: Type `n`
- Setup e2e tests with Nightwatch: Type `n`
- Run npm install?: Select `Yes, use NPM`

This will generate a new project within a directory named `<project-name>`. Once the generator has finished, go ahead and cd into the directory.

### File Structure
If you are unfamiliar with a webpack application, here are a few highlights the file structure that has been created for us.
- build: This contains the webpack config files. We won't need to touch this folder for this tutorial, but if you needed to add any modules to webpack, this is where you would do it.
- config: Project config including dev-server configuration and environment configuration.
- node_modules: This is where all of the application's dependencies are installed.
- src: This is where our application lives. This folder will contain all of our application's components and assets. We will spend almost all of our time working within this folder.
- static: This folder is where any static assets can be stored. These assets will not be pre-processed and will simply be copied as-is into our application when built.
- tests: As the name implies, all of our unit tests will go here.
- package.json: This file is where all meta-data regarding our application is defined along with where our application's dependencies are declared.
- index.html: This is our application's entry point. The vue app we develop will be embedded within this document's body tags.


### Running The Dev-server
We can take a look at the application that has been generated by starting the webpack-dev-server using the following command:
``` bash
$ npm run start
```

This will start a local server on port 8080, so we can take a look at our application at http://localhost:8080. As we develop our application, webpack will detect any changes we make and will automatically reload our webpage for us - pretty slick.

To stop the server simply use `ctrl-c`


## 3. Adding A Few Dependencies.
Our application has almost everything we will need, but there are a couple packages that will need to be installed. To do this will need to declare them in the `package.json` file, so go ahead and open that up and add the following within the `dependencies` object.

##### 3.1 package.json
``` json
"dependencies": {
  ...
  "vuex": "^3.0.1",
  "axios": "^0.17.1",
  "@aspnet/signalr-client": "^1.0.0-alpha2-final"
}
```

Once you have saved the file, you can install these packages with either:
``` bash
$ npm install
```

In this application we'll use font awesome, so we'll need to add the webfont. To do this, simply add the link tag to index.html:

##### 3.2 Index.html
``` html
<head>
  ...
  <link href="https://use.fontawesome.com/releases/v5.0.4/css/all.css" rel="stylesheet">
</head>
```

We'll also want to include a stylesheet so that we dont have to worry about styles as we develop.

Copy the contents of [this css file](https://raw.githubusercontent.com/unm-idi/vlack/master/dist/static/css/app.6f59a85698263d006607c75badc92bce.css) to /src/assets/styles.css and then in main.js, require the file:

##### 3.3 main.js
```js
require('./assets/styles.css')
```

Now we're all set up to begin developing our vue application!

## 4. Extend Vue With HTTP/Websock Functionality
First, lets set some environment variables to hold the endpoints of our backend api:

##### 4.1 config/dev.env.js
``` js
'use strict'
const merge = require('webpack-merge')
const prodEnv = require('./prod.env')

module.exports = merge(prodEnv, {
  NODE_ENV: '"development"',
  HTTP_ENDPOINT: '"http://ec2-35-167-99-178.us-west-2.compute.amazonaws.com:5000/api"',
  WS_ENDPOINT: '"http://ec2-35-167-99-178.us-west-2.compute.amazonaws.com:5000/socket"'
})
```

Next, we need to import both axios and signalR into application:

##### 4.2 main.js
``` js
import axios from 'axios'
import * as signalR from '@aspnet/signalr-client'
```

After we import the libraries, we can extend Vue so that they are available within our components:

##### 4.3 main.js
``` js
// Axios Setup
Vue.prototype.$axios = axios.create({
  baseURL: process.env['HTTP_ENDPOINT']
})

// SignalR Setup
Vue.prototype.$signalR = signalR
```

## 5. Channels List

### Displaying a List of Channels

To dispaly a list of channels, first we'll need to create a model in our component for storing the channels:

##### 5.1 App.vue (component)
``` js
  name: 'App',
  data () {
    return {
      channels: []
    }
  }
```

Next we'll create a method that will fetch channels from the server and store them in the model:

##### 5.2 App.vue (component)
``` js
methods: {
  getChannels () {
    this.$axios.get('/channel')
      .then((response) => {
        this.channels = response.data
      })
  }
}
```

We want this method to be called as soon as the component is created, so we'll add it to the component's *created* lifecycle hook.

##### 5.3 App.vue (component)
``` js
created () {
  this.getChannels()
},
```

We can see that this all works by inspecting the component through our browser's vue dev tools.

Next, we'll want to display a list of channels in component's template using the *v-for* directive:

##### 5.4 App.vue (template)
``` html
<div id="app">
  <div class="sidebar">
    <h3>Vlack</h3>
    <h4>Channels</h4>
    <a v-for="channel in channels" :key="channel.id">{{channel.name}}</a>
  </div>
  
  <div class="content">
    <router-view/>
  </div>
</div>
```

### Creating A New Channel

We're going to create a new component that will allow us to create a new channel. Within the component's folder, create a new file called *ChannelForm.vue* and populate it with the following to instantiate a new vue component:

##### 5.5 ChannelForm.vue
``` html
<template>
  <div class="new-channel-form">
    <h1>New Channel</h1>
  </div>
</template>

<script>
export default {
  name: 'ChannelForm'
}
</script>
```

To access this component as a 'page', we'll need to assign it to a route via the router:

##### 5.6 routes/index.js
``` js
  ...
  import ChannelForm from '@/components/ChannelForm'
  ...
  export default new Router({
  routes: [
    ...
    {
      path: '/channel/new',
      name: 'ChannelForm',
      component: ChannelForm
    }
  ]
})
```

We can access this new Channel Form Component by visiting *localhost:8080/channel/new*. We can also add a link to this component in our main App template:

##### 5.7 App.vue (template)
``` html
<div class="sidebar">
  <h3>Vlack</h3>
  <h4>Channels</h4>
  <router-link to="/channel/new" class="new-channel-link"><i class="fas fa-plus-square"></i></router-link>
  ...
</div>
```

Now we can get to our new channel form page, so lets go back to our ChannelForm.vue component. The first thing we'll need to do is add the model that will represent the data that makes up a channel. In this case, just a name:

##### 5.8 ChannelForm.vue (component)
``` js
name: 'ChannelForm',
data: () => {
  return {
    channelName: ''
  }
}
```

To collect this name, we can bind this model attribute to a text field in the template with the *v-model* directive:

##### 5.9 ChannelForm.vue (template)
``` html
<div class="new-channel-form">
  <h1>New Channel: {{channelName}}</h1>
  <input type="text" v-model="channelName" />
  <button>Create</button>
</div>
```

This change binds the channelName attribute to the value of the text field. We can see this through the {{channelName}} handlebars we added. Everytime vue detects a change in its models, it will update the view accordingly. This is called reactivity.

So far we've collected the information we need to create a channel, so the next step is to then submit this data to the server to create the new channel. We'll create a method that does this in the component's methods block:

##### 5.10 ChannelForm.vue (component)
``` js
methods: {
  createChannel () {
    this.$axios.post('/channel', {Name: this.channelName})
      .then((response) => {
        this.$router.push('/')
      })
  }
}
```

This will make a request to the server to create the channel, and upon a succesful response, we will navigate back to the home path. The last step is to simply bind this method to a button in the template:

##### 5.11 ChannelForm.vue (template)
``` html
<button v-on:click="createChannel" v-bind:disabled="channelName === ''">Create</button>
```

The *v-on* directive binds an event (a click event in this case) to a method on the component's instance. The *v-bind* attribute binds the button's disabled attribute to the expression we pass into it - in this case we're disabling the button if the channelName model is blank.


Notice that when we create a channel, we'll be routed back to the home page, but the channel we've created won't appear in the list until we refresh the page. This is because we are only updating the App components list of channels when the component is created, and because this is an SPA, there is no actual page load when we change routes. Therefore the App component is not re-created - it's the same instance of the component. We'll fix this issue by introducing an application state store.


## 6. Create The Application State Via Vuex
Vuex provides a global store and state management functionality to a Vue application. We're going to create a store that will contain the list of channels as well as a user session, which we'll set up next.

First, we'll go ahead and simply create the basic store by creating a file within *src* name store.js

##### 6.1 store.js
``` js
export default {
  state: {
    channels: []
  },
  mutations: {
  }
}
```

We will then need to tell our vue application to use this store:

##### 6.2 main.js
``` js
// Under import Vue ...
import Vuex from 'vuex'
import applicationState from './store';

...

Vue.use(Vuex)
const store = new Vuex.Store(applicationState)


/* eslint-disable no-new */
new Vue({
  el: '#app',
  router,
  store,
  components: { App },
  template: '<App/>'
})
```

Our vue application can now access the Vuex store. We will now refactor App.vue to use the store's channel list, rather than its own, but first we need to write the mutations that will allow us to access and modify the state:

##### 6.3 store.js
``` js
mutations: {
  setChannels (state, channelList) {
    state.channels = channelList
  },

  addChannel (state, channel) {
    state.channels.push(channel)
  }
}
```

Now we can refactor App.vue to use this store:

##### 6.4 App.vue (component)
``` js
export default {
  name: 'App',

  computed: {
    channels () {
      return this.$store.state.channels
    }
  },

  created () {
    this.getChannels()
  },

  methods: {
    getChannels () {
      this.$axios.get('/channel')
        .then((response) => {
          this.$store.commit('setChannels', response.data)
        })
    }
  }
}
```

We'll also refactor ChannelForm to store the newly created channel in the store:

##### 6.5 ChannelForm.vue (component)
``` js
createChannel () {
  this.$axios.post('/channel', {Name: this.channelName})
    .then((response) => {
      this.$store.commit('addChannel', response.data)
      this.$router.push('/')
    })
}
```

Now when we create a new channel, it'll be added to the channel list in the App component


## 7. User Session
Before we can start sending messages in our channels, we need to have some notion of a user session. We're not going to develop a full-fledged authenticated user session setup, but we are going to ask users to sign in before they use the app and store their name in the store as well as localstorage.

##### 7.1 store.js
``` js
state: {
  ...
  user: null
},
mutations: {
  ...
  setUser (state, username) {
    state.user = username
    window.sessionStorage.setItem('vlackUser', username)
  }
}
```

Now we can provide our App component the ability to make sure that someone is signed in before using the app, and sign them in if not.

##### 7.2 App.vue (component)
``` js
data: () => {
  return {
    userName: ''
  }
},

computed: {
  user () {
    return this.$store.state.user
  }
  ...
}
...
methods: {
  ...
  login () {
    this.$store.commit('setUser', this.userName)
  }
}
```

##### 7.3 App.Vue (template)
``` html
<div id="app">
  <template v-if="user">
    <div class="sidebar">
      <h3>{{user}}</h3>
      ...
    </div>
    ...
  </template>

  <template v-else>
    <div class="sign-in-form">
      <h1>Sign In</h1>
      <input type="text" v-model="userName" />
      <button @click="login()" :disabled="userName === ''">Login</button>
    </div>
  </template>
</div>
```

One more change to allow our app to make use of sessionStorage:

##### 7.4 App.vue (component)
``` js
created () {
  const loggedInUser = window.sessionStorage.getItem('vlackUser')
  if (loggedInUser) {
    this.$store.commit('setUser', loggedInUser)
  }
  this.getChannels()
},
```

## 8. Channel View
We'll now create the the component that will serve as the chat view for each channel we've created. Create a file name *Channel.vue* in the Components folder. Before we add anything to this component, lets set up the router to use it.

##### 8.1 routes/index.js
```js
routes: [
  ...
  {
    path: '/channel/:id',
    name: 'Channel',
    component: Channel
  }
]
```

We'll also want to convert our channel links in App.vue to use this route.

##### 8.2 App.vue (template)
```html
<router-link
  v-for="channel in channels"
  :key="channel.id"
  :to="{name: 'Channel', params: {id: channel.id}}"
>
  # {{channel.name}}
</router-link>
```

This route, we've set up with a parameter called *id* which we'll use in our component to know what channel we are viewing. Copy the following into Channel.vue to get started.

##### 8.3 Channel.vue
```html
<template>
  <div class="channel">
    <div class="channel-header">
      <h3>{{name}}</h3>
    </div>

    <div class="messages">
      <p v-for="message in messages" :key="message.id">{{message.body}}</p>
    </div>

    <div class="new-message"></div>
  </div>
</template>

<script>
export default {
  name: 'Channel',

  data: () => {
    return {
      name: null,
      id: null,
      messages: []
    }
  },

  created () {
    this.getChannel()
  },

  methods: {
    getChannel () {
    }
  }
}
</script>
```

Now we'll impliment the *getChannel* to make a request for the channel with the id that was passed into the url as a parameter. We can access this varialbe through the $route attribute availabile to the instance.

##### 8.4 Channe.vue (component)
```js
getChannel () {
  this.$axios.get('/channel/' + this.$route.params.id)
    .then((response) => {
      this.name = response.data.name
      this.id = response.data.id
      this.messages = response.data.messages
    })
}
```

When we click on a channel for the first time we'll navigate to this component and should see the name of the channel. However, when we click on another channel nothing changes. This is because vue recognizes that the new route uses the same component that is being shown, and it reuses the instance - therefore the created method is not going to be called again. To get around this, we can detect a route change via vue's *watch* and then reload the data with the new id parameter. 

##### 8.5 Channel.vue (component)
```js
...
watch: {
  '$route': function () {
    this.getChannel()
  }
},
```

Now our component should behave as expected. When the route changes, our component adapts.

## 9. Message Component
Although all of the components we have created so far act as 'pages' in our application, they will most commonly be used to create self-contained pieces of an application's ui that can be used like custom html elements. This is a great way to keep our applications modual and maintainable by encapsulating both UI and functionality together in reusable packages. In this case, we're going to create a component to display our messages. To get started, create a file named Message.vue in the components folder and populate it with the following:

##### 9.1 Message.vue
```html
<template>
  <div class="message">
    I'm a message
  </div>
</template>

<script>
export default {
  name: 'Message'
}
</script>
```

Next, we'll want to register this component in the Channel component so we can use it in the view.

##### 9.2 Channel.vue (component)
```js
import Message from './Message'
...
export default {
  ...
  components: {
    'message': Message
  }
}
```

Now we've registered this component with the selector, *message*, which can be used in the template. Go ahead and replace the p tags with message tags:

##### 9.3 Channel.vue (template)
```html
<div class="messages">
  <message 
    v-for="message in messages" 
    :key="message.id"
  >
  </message>
</div>
```

Now we should see "I'm a message" where our messages used to be. Of course, we actually want to see our own messages, so we'll need to pass the message object from the channel component to the message component. Vue allows us to do this through props. Update the message component with the following:

##### 9.4 Message.vue
```html
<template>
  <div class="message">
    <b>{{message.user}}</b> <span>{{message.createdAt}}</span>
    <p>{{message.body}}</p>
  </div>
</template>

<script>
export default {
  name: 'Message',
  props: ['message']
}
</script>
```

By declaring a message prop on our component, we can then pass an object into it with the following:

##### 9.5 Channe.vue (template)
```html
<message 
  v-for="message in messages" 
  :key="message.id"
  :message="message"
>
</message>
```

We should now see our messages!

There might be times when we want to modify the data that is passed into our components as props, however we cannot simply change them from within the component. By default vue supports one way data flow between a parent and a child. If the parent's data changes then it will automatically be propagated to the child, but not the other way around. the proper way to handle this scenarios is for the child to alert the parent of a change it wants to make and let the parent actually perform the transformation. In our message component, we're going to want our message component to alert the channel component to 'star' that message. We'll do this by emitting an event:

##### 9.6 Message.vue
```html
<template>
  <div class="message" :class="{starred: message.starred}">
    <b>{{message.user}}</b> <span>{{message.createdAt}}</span>
    <p>{{message.body}}</p>
    <a @click="star"><i class="far fa-star"></i></a>
  </div>
</template>

<script>
export default {
  name: 'Message',
  props: ['message'],

  methods: {
    star () {
      this.$emit('star')
    }
  }
}
</script>
```

The channel View can then detect this event:

##### 9.7 Channel.vue (template)
```html
<div class="messages">
  <message 
    v-for="(message, i) in messages" 
    :key="message.id"
    :message="message"
    @star="starMessage(i)"
  >
  </message>
</div>
```

And the method to actually make the change:

##### 9.8 Channel.vue (component)
```js
methods: {
  ...
  starMessage (i) {
    this.messages[i].starred = true
  }
}
```

## 10. Creating New Messages
To begin creating messages, we'll need to create a model to store a new message and a method for making the post request:

##### 10.1 Channel.vue (component)
```js
data: () => {
  return {
    ...
    newMessage: ''
  }
}
...
methods: {
  createMessage() {
    if (this.newMessage !== '') {
      const messageParams = {
        user: this.$store.state.user,
        body: this.newMessage,
        ChannelId: this.id
      }
      this.$axios.post('/message', messageParams)
        .then((response) => {
          this.newMessage = ''
        })
    }
  }
  ...
}
```
And of course, we'll need the form:

##### 10.2 Channel.vue (template)
```html
...
<div class="new-message">
  <textarea v-model="newMessage" @keydown.enter.prevent="createMessage()"></textarea>
</div>
...
```

Now we can create messages and see them once we reload the page, but thats no fun so we're going to add websockets so that the server can alert our application that a new comment has been made.

##### 10.3 Channel.vue (component)
```js
methods: {
  setupSocket () {
      const transport = this.$signalR.TransportType.WebSockets
      const socketEndpoint = process.env['WS_ENDPOINT'] + '?channel_id='
      this.socketConnection = new this.$signalR.HubConnection(socketEndpoint + this.id, {transport: transport})
      this.socketConnection.on('broadcastMessage', (name, message) => {
        this.messages.push(message)
      })
      this.socketConnection.start()
    },
  ...
  getChannel () {
    this.$axios.get('/channel/' + this.$route.params.id)
        .then((response) => {
          ...
          this.setupSocket()
        })
  }
}
```

We've created a new method that sets up the socket and we're going to call it as soon as we finish fetching the channel. We call the method there, becasue we want to ensure that we have successfully fetched the channel's id before setting the connection up. Now one more quick step, just to make our code a bit cleaner: whenever we change routes we want to disconnect the websocket connection before starting a new one:

##### 10.4 Channel.vue (component)
```js
created () {}
...
beforeRouteUpdate (to, from, next) {
  this.socketConnection.stop()
  next()
},

beforeRouteLeave (to, from, next) {
  this.socketConnection.stop()
  next()
},
```

To add the finishing touch we're going to have the messages scroll to the bottom every time a new message is added:

##### 10.5 Channel.vue (component) 
```js
watch: {
  ...
  'messages': function () {
    setTimeout(() => {
      this.$el.querySelector('.messages').scrollTo(0, 1000000000)
    }, 100);
  }
}
```